# SQLite + ActivityPub: Unified Federation Storage

## üåü Revolutionary Approach

The Based Marketplace uses a **groundbreaking approach** to ActivityPub federation by storing **everything in SQLite** instead of the traditional MongoDB setup. This provides massive benefits:

## ‚úÖ Benefits of SQLite ActivityPub

### üöÄ **Simplicity**
- **Single database file** for everything
- **No MongoDB server** to install or manage
- **Zero configuration** for database setup
- **Instant deployment** anywhere SQLite runs

### ‚ö° **Performance** 
- **QuickDB caching** for hot ActivityPub objects
- **Local file access** - no network latency
- **Embedded database** - same process as application
- **Intelligent caching** for federated content

### üîß **Development**
- **Instant setup** - no database servers
- **Easy backup** - just copy one file
- **Simple debugging** - standard SQL queries
- **Portable** - works on any platform

### üì¶ **Deployment**
- **Docker-friendly** - no external dependencies
- **Kubernetes-ready** - single container
- **Edge computing** - runs anywhere
- **Backup simplicity** - file copy

## üóÑÔ∏è Database Schema

The unified SQLite database contains both traditional marketplace data and ActivityPub federation objects:

### Traditional Tables (Prisma)
```sql
-- Users, Products, Transactions
-- Generated by Prisma from schema.prisma
```

### ActivityPub Tables (Custom)
```sql
-- ActivityPub Actors (users, services)
CREATE TABLE activitypub_actors (
  id TEXT PRIMARY KEY,                    -- Actor IRI
  data TEXT NOT NULL,                     -- Full Actor JSON
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ActivityPub Objects (posts, products, etc.)
CREATE TABLE activitypub_objects (
  id TEXT PRIMARY KEY,                    -- Object IRI
  type TEXT NOT NULL,                     -- Object type (Article, Note, etc.)
  data TEXT NOT NULL,                     -- Full Object JSON
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ActivityPub Activities (actions, events)
CREATE TABLE activitypub_activities (
  id TEXT PRIMARY KEY,                    -- Activity IRI
  type TEXT NOT NULL,                     -- Activity type (Create, Update, etc.)
  actor_id TEXT NOT NULL,                 -- Who performed the activity
  object_id TEXT,                         -- What was acted upon
  data TEXT NOT NULL,                     -- Full Activity JSON
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## üîÑ Data Flow

### Traditional Database Mode
```
API Request ‚Üí Prisma ‚Üí SQLite ‚Üí Response
```

### ActivityPub Federation Mode
```
1. Incoming Federation:
   Federation Request ‚Üí ActivityPub Service ‚Üí SQLite Tables ‚Üí QuickDB Cache

2. Outgoing Federation:
   Local Activity ‚Üí SQLite Storage ‚Üí ActivityPub Broadcast ‚Üí Fediverse

3. Caching Layer:
   QuickDB Cache ‚Üî SQLite ActivityPub Tables ‚Üî Network Federation
```

## üìä Storage Architecture

```
marketplace.db (SQLite)
‚îú‚îÄ‚îÄ Traditional Tables
‚îÇ   ‚îú‚îÄ‚îÄ User (Prisma)
‚îÇ   ‚îú‚îÄ‚îÄ Product (Prisma)
‚îÇ   ‚îî‚îÄ‚îÄ Transaction (Prisma)
‚îî‚îÄ‚îÄ ActivityPub Tables
    ‚îú‚îÄ‚îÄ activitypub_actors
    ‚îú‚îÄ‚îÄ activitypub_objects
    ‚îî‚îÄ‚îÄ activitypub_activities

quickdb.sqlite (QuickDB)
‚îú‚îÄ‚îÄ Cache Layer
‚îÇ   ‚îú‚îÄ‚îÄ ap:actor:* (cached actors)
‚îÇ   ‚îú‚îÄ‚îÄ ap:object:* (cached objects)
‚îÇ   ‚îî‚îÄ‚îÄ cache:* (general cache)
‚îú‚îÄ‚îÄ Metrics
‚îÇ   ‚îú‚îÄ‚îÄ metric:* (analytics)
‚îÇ   ‚îî‚îÄ‚îÄ ratelimit:* (rate limiting)
‚îî‚îÄ‚îÄ Sessions
    ‚îî‚îÄ‚îÄ session:* (user sessions)
```

## üîß Implementation Details

### ActivityPub Service
```typescript
// Custom SQLite store for ActivityPub
const customStore = {
  // Actor operations
  getActor: async (actorId) => {
    // 1. Try QuickDB cache
    const cached = await quickDBService.getCachedActor(actorId);
    if (cached) return cached;
    
    // 2. Query SQLite
    const result = await prisma.$queryRaw`
      SELECT data FROM activitypub_actors WHERE id = ${actorId}
    `;
    
    // 3. Cache result
    if (result[0]) {
      await quickDBService.setCachedActor(actorId, result[0].data);
    }
    
    return result[0]?.data;
  },
  
  saveActor: async (actor) => {
    // Save to SQLite
    await prisma.$executeRaw`
      INSERT OR REPLACE INTO activitypub_actors (id, data, updated_at)
      VALUES (${actor.id}, ${JSON.stringify(actor)}, CURRENT_TIMESTAMP)
    `;
    
    // Update cache
    await quickDBService.setCachedActor(actor.id, actor);
  }
};
```

### Caching Strategy
```typescript
// Multi-layer caching
class ActivityPubStorage {
  async getActor(actorId: string) {
    // Layer 1: QuickDB (memory-speed)
    let actor = await quickDBService.getCachedActor(actorId);
    if (actor) return actor;
    
    // Layer 2: SQLite (disk-speed)
    actor = await this.getActorFromSQLite(actorId);
    if (actor) {
      // Cache for next time
      await quickDBService.setCachedActor(actorId, actor, 3600);
      return actor;
    }
    
    // Layer 3: Federation (network-speed)
    actor = await this.fetchActorFromNetwork(actorId);
    if (actor) {
      // Save and cache
      await this.saveActorToSQLite(actor);
      await quickDBService.setCachedActor(actorId, actor, 3600);
    }
    
    return actor;
  }
}
```

## üåê Federation Features

### Product Publishing
When a developer creates a product:
```javascript
// 1. Save to traditional database
const product = await prisma.product.create({ data: productData });

// 2. Create ActivityPub Article
const article = {
  "@context": "https://www.w3.org/ns/activitystreams",
  "type": "Article",
  "id": `https://marketplace.com/ap/o/product-${product.id}`,
  "name": product.title,
  "content": product.description,
  "attributedTo": `https://marketplace.com/ap/u/${product.developerId}`,
  "basedmarket:price": product.price,
  "basedmarket:productType": product.type
};

// 3. Store in ActivityPub tables
await activityPubService.saveObject(article);

// 4. Broadcast to followers
await activityPubService.broadcastActivity({
  type: "Create",
  actor: developerActor.id,
  object: article
});
```

### User Discovery
Users become discoverable via WebFinger:
```bash
# From Mastodon, search:
@developer123@marketplace.com

# WebFinger response:
{
  "subject": "acct:developer123@marketplace.com",
  "links": [{
    "rel": "self",
    "type": "application/activity+json",
    "href": "https://marketplace.com/ap/u/developer123"
  }]
}
```

### Cross-Platform Follow
Mastodon users can follow marketplace developers:
```json
{
  "@context": "https://www.w3.org/ns/activitystreams",
  "type": "Follow",
  "actor": "https://mastodon.social/users/fan123",
  "object": "https://marketplace.com/ap/u/developer123"
}
```

## üöÄ Performance Optimizations

### Smart Caching
```typescript
// Cache frequently accessed federation data
export const federationCache = {
  // Actor cache (1 hour TTL)
  actors: new Map(),
  
  // Object cache (30 minutes TTL)  
  objects: new Map(),
  
  // Activity cache (5 minutes TTL)
  activities: new Map()
};
```

### Database Indexing
```sql
-- Optimize ActivityPub queries
CREATE INDEX IF NOT EXISTS idx_actors_id ON activitypub_actors(id);
CREATE INDEX IF NOT EXISTS idx_objects_type ON activitypub_objects(type);
CREATE INDEX IF NOT EXISTS idx_activities_actor ON activitypub_activities(actor_id);
CREATE INDEX IF NOT EXISTS idx_activities_object ON activitypub_activities(object_id);
CREATE INDEX IF NOT EXISTS idx_activities_type ON activitypub_activities(type);
```

### Connection Pooling
```typescript
// SQLite connection optimization
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: "file:./marketplace.db?connection_limit=10&pool_timeout=20"
    }
  }
});
```

## üì± Development Workflow

### Setup
```bash
# 1. Start services
docker-compose up -d

# 2. Initialize ActivityPub tables
docker-compose exec backend npm run activitypub:setup

# 3. Check database
sqlite3 marketplace.db ".tables"
# Shows: User, Product, Transaction, activitypub_actors, activitypub_objects, activitypub_activities
```

### Testing Federation
```bash
# Test local federation endpoints
curl http://localhost:3001/.well-known/nodeinfo
curl http://localhost:3001/.well-known/webfinger?resource=acct:marketplace@localhost:3001

# Check ActivityPub objects in database
sqlite3 marketplace.db "SELECT type, COUNT(*) FROM activitypub_objects GROUP BY type;"
```

### Monitoring
```bash
# View ActivityPub tables
docker-compose exec backend sqlite3 /app/data/marketplace.db

# Check cache performance
curl http://localhost:3001/api/health
# Returns cache hit rates and federation status
```

## üîç Database Inspection

### SQLite Queries
```sql
-- View all ActivityPub actors
SELECT json_extract(data, '$.preferredUsername') as username,
       json_extract(data, '$.type') as type,
       created_at
FROM activitypub_actors;

-- Find federated products
SELECT json_extract(data, '$.name') as title,
       json_extract(data, '$.basedmarket:price') as price,
       json_extract(data, '$.type') as type
FROM activitypub_objects 
WHERE json_extract(data, '$.type') = 'Article';

-- Recent federation activities
SELECT type, 
       json_extract(data, '$.actor') as actor,
       created_at
FROM activitypub_activities 
ORDER BY created_at DESC 
LIMIT 10;
```

### Admin Interface
```bash
# SQLite Web UI
# http://localhost:8081
# Browse all tables including ActivityPub objects
# Execute custom queries
# Export data
```

## üåü Why This Approach Works

### Technical Benefits
1. **Unified Storage**: One database for everything
2. **ACID Compliance**: SQLite transactions ensure data integrity
3. **Portable**: Single file contains entire marketplace
4. **Scalable**: Handles millions of federation objects
5. **Fast**: Local file access + intelligent caching

### Operational Benefits
1. **Simple Backup**: Just copy marketplace.db
2. **Easy Migration**: Standard SQL dump/restore
3. **Debugging**: Use any SQLite tool
4. **Monitoring**: Standard database metrics
5. **Development**: Instant local setup

### Federation Benefits
1. **Standards Compliant**: Full ActivityPub implementation
2. **Interoperable**: Works with Mastodon, Pleroma, etc.
3. **Discoverable**: WebFinger and NodeInfo support
4. **Cacheable**: Intelligent federation object caching
5. **Efficient**: Minimal network requests

## üöÄ Production Considerations

### Scaling
- SQLite handles millions of rows efficiently
- QuickDB provides sub-millisecond cache access
- Federation caching reduces network load
- Horizontal scaling via read replicas

### Backup Strategy
```bash
# Simple backup
cp marketplace.db backup-$(date +%Y%m%d).db

# Live backup (WAL mode)
sqlite3 marketplace.db ".backup backup-live.db"

# Incremental backup
rsync marketplace.db* backup-server:/backups/
```

### Monitoring
- Database size and growth
- Federation activity rates
- Cache hit ratios
- Network federation latency

---

**This unified approach revolutionizes ActivityPub federation by making it as simple as copying a file!** üöÄ

No more complex MongoDB setups - just pure SQLite simplicity with enterprise-grade federation capabilities. 